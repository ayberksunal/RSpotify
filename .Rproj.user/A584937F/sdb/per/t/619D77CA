{
    "collab_server" : "",
    "contents" : "\nlibrary(devtools)\nlibrary(Rspotify)\n\n#To contact with  API service by appID  cliend_ID and Client_Secret\n#They can be reached from the website of spotify\nkeys <- spotifyOAuth(app_id = \"ayberk\", client_id = \"782a5daa8f574ba0bcaf9e8af852ad07\", client_secret = \"b1d2f5ce612e46c5a893db6099a5a2ec\")\neurovisionPlaylists_Years_cleared<-data.frame()\n\n#Finds the all playlist of the user with 50 offset\n#Offset determines the limit of rows\neurovisionPlaylists_Years<-getPlaylist(\"1116592061\",offset=50,token=keys);\n\n#To erase the wanted rows \n#an other way it using \"filter\"\nfor (i in 34:50){\n  eurovisionPlaylists_Years_cleared<-data.frame(rbind(eurovisionPlaylists_Years_cleared,eurovisionPlaylists_Years[i,1:3]))\n}\n\n#empty frame to store each features of songs\nfeaturesEurovision<-data.frame()\n\n#to store the result \nSonuc<-data.frame(id=\"1\",yıl=\"yıl\",oran=0,danceability='Bilinmiyor')\n#loops all rows of playslist\n#to look the songs of these playlists\nfor(i in 2:length(eurovisionPlaylists_Years_cleared$id))\n{\n \n  #to see which country's id consuming\n  eurovision_playlist<-data.frame()\n  print(eurovisionPlaylists_Years_cleared$name[i])\n  eurovision_playlist<-data.frame()\n  #to find all song of one country\n  eurovision_playlist <- getPlaylistSongs(\"1116592061\",eurovisionPlaylists_Years_cleared$id[i],token=keys)\n  #features[\"countryname\"]<-allPlaylistsInfo$name[1]\n  \n  #stores row number of playlist for forloop\n  rowNumber<-c(dim(eurovision_playlist))\n  rowNumber<-c(rowNumber[1])\n  count<-0\n  #looks all song of playlists\n  for(a in eurovision_playlist$id){\n    Sys.sleep(0.09)\n    count<-count+1\n    \n    #to get JSON result\n    req <- httr::GET(paste0(\"https://api.spotify.com/v1/audio-features/\", \n                            a), httr::config(token = keys))\n    json1 <- httr::content(req)\n    dadosEuro = data.frame(id = json1$id, danceability = json1$danceability, \n                       energy = json1$energy, key = json1$key, loudness = json1$loudness, \n                       mode = json1$mode, speechiness = json1$speechiness, \n                       acousticness = json1$acousticness, instrumentalness = json1$instrumentalness, \n                       liveness = json1$liveness, valence = json1$valence, \n                       tempo = json1$tempo, duration_ms = json1$duration_ms, \n                       time_signature = json1$time_signature,\n                       stringsAsFactors = F)\n    #adds the name of the list\n    dadosEuro$Yıl<-eurovisionPlaylists_Years_cleared$name[i]\n    featuresEurovision <- rbind( featuresEurovision, dadosEuro)\n    \n  }\n  print(count)\n  \n}\n\n\n# It clusters all songs by their energy column \n# clustering depends on quantiles levels\nfeaturesEurovisionBirUlke2$Enerjisi<-\"Bilinmiyor\"\n#featuresEurovisionBirUlke2<-featuresEurovisionBirUlke\nquantilesEurovision<-quantile(featuresEurovisionBirUlke2$energy)\nfor(k in 1:nrow(featuresEurovisionBirUlke2)){\n  if(featuresEurovisionBirUlke2$energy[k] < quantilesEurovision[2]){\n    featuresEurovisionBirUlke2$Enerjisi[k] = \"Low Energic\"\n  }\n  if(featuresEurovisionBirUlke2$energy[k] >= quantilesEurovision[2] && featuresEurovisionBirUlke2$energy[k] < quantilesEurovision[4])\n  {\n    featuresEurovisionBirUlke2$Enerjisi[k]='Energic'\n  }\n  \n  if(featuresEurovisionBirUlke2$energy[k] > quantilesEurovision[4] ){\n    featuresEurovisionBirUlke2$Enerjisi[k]='High Energic'\n  }\n}\n\n\n  \n  ############################################ COMMENT THIS PART BEFORE RUN########################################\n#To find the winners of each years song features\nfeaturesEurovisionBirUlke<-data.frame()\n\nSonuc<-data.frame(id=\"11111111\",yıl=\"yıl\",oran=0000,danceability='Bilinmiyor')\nfor(i in 1:length(eurovisionPlaylists_Years_cleared$id))\n{\n  #to see which country's id consuming\n  eurovision_playlist<-data.frame()\n  print(eurovisionPlaylists_Years_cleared$name[i])\n  eurovision_playlist<-data.frame()\n  #tek ulkenın tüm sarkıları\n  eurovision_playlist <- getPlaylistSongs(\"1116592061\",eurovisionPlaylists_Years_cleared$id[i],token=keys)\n  #features[\"countryname\"]<-allPlaylistsInfo$name[1]\n  \n  rowNumber<-c(dim(eurovision_playlist))\n  rowNumber<-c(rowNumber[1])\n  count<-0\n  for(a in 1:1){\n    Sys.sleep(0.01)\n    count<-count+1\n    #  cc<-data.frame(eurovision_playlist[a,2])\n    req <- httr::GET(paste0(\"https://api.spotify.com/v1/audio-features/\", \n                            eurovision_playlist$id[a]), httr::config(token = keys))\n    json1 <- httr::content(req)\n    dadosEurobirUlke<-data.frame()\n    dadosEurobirUlke = data.frame(id = json1$id, danceability = json1$danceability, \n                           energy = json1$energy, key = json1$key, loudness = json1$loudness, \n                           mode = json1$mode, speechiness = json1$speechiness, \n                           acousticness = json1$acousticness, instrumentalness = json1$instrumentalness, \n                           liveness = json1$liveness, valence = json1$valence, \n                           tempo = json1$tempo, duration_ms = json1$duration_ms, \n                           time_signature = json1$time_signature,\n                           stringsAsFactors = F)\n    #adds the name of the list\n    dadosEurobirUlke$Yıl<-eurovisionPlaylists_Years_cleared$name[i]\n    featuresEurovision <- rbind( featuresEurovision, dadosEurobirUlke)\n    \n  }\n  print(count)\n  \n}\n\n############################################ COMMENT THIS PART BEFORE RUN########################################\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
    "created" : 1513598091366.000,
    "dirty" : true,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1930813427",
    "id" : "619D77CA",
    "lastKnownWriteTime" : 1514307631,
    "last_content_update" : 1514307637946,
    "path" : "~/RSpotify/eurovisionSpotify.R",
    "project_path" : "eurovisionSpotify.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}